#!/usr/bin/env ruby

$: << File.expand_path(File.dirname(__FILE__))
require 'origin_constants'
unless ENV['SKIP_SETUP']
  require 'lib/openshift/setup_helper'
  SetupHelper::ensure_build_requirements
end
require 'rubygems'
require 'thor'
require 'fileutils'
require 'lib/openshift'
require 'pp'
require 'yaml'
require 'builder'

include FileUtils

module Origin
  class BuilderPlugin < OpenShift::Builder
    include OpenShift::BuilderHelper
    
    desc "docs", "Build OpenShift Origin Ruby documentation"
    method_option :verbose, :type => :boolean, :default => false, :desc => "Enable verbose logging"    
    # Task to build YARD documentation for all Ruby Code
    #
    # @param options [Hash] Thor options hash
    #   - --verbose: Enable verbose logging
    def docs
      options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR
      repo_parent_dir = File.expand_path("#{File.dirname(__FILE__)}/../../")      
      remove_dir "#{repo_parent_dir}/origin-docs"
      empty_directory "#{repo_parent_dir}/origin-docs"
      
      unless File.exist?("/tmp/yard-js")
        run "git clone git://github.com/lsegal/yard-js /tmp/yard-js"
        inside("/tmp/yard-js") { run "bundle install" }
      end
      
      inside(repo_parent_dir) do
        doc_files = Dir["#{repo_parent_dir}/origin-server/documentation/*.md"].join(",")
        inside("origin-server/documentation") { run "yardoc --markup=markdown --output-dir '#{repo_parent_dir}/origin-docs' --files #{doc_files}" }
        run %{yardoc --output-dir '#{repo_parent_dir}/origin-docs/broker' --main origin-server/documentation/broker.md --private --protected --exclude test \
          #{Dir["origin-server/broker/**/*.rb"].join(' ')} \
          #{Dir["origin-server/controller/**/*.rb"].join(' ')}}
        run %{yardoc --output-dir '#{repo_parent_dir}/origin-docs/rest_api' --main origin-server/documentation/rest_api.md --api REST \
          #{Dir["origin-server/controller/**/*.rb"].join(' ')}}
        run "yardoc --output-dir '#{repo_parent_dir}/origin-docs/broker_models' --main origin-server/documentation/broker_models.md --private --protected --api model #{Dir["origin-server/controller/**/*.rb"].join(' ')}"
        run "yardoc --output-dir '#{repo_parent_dir}/origin-docs/node' --main origin-server/documentation/node.md --private --protected --exclude test #{Dir["origin-server/node/**/*.rb"].join(' ')}"
        run "yardoc --output-dir '#{repo_parent_dir}/origin-docs/common' --main origin-server/documentation/common.md --private --protected --exclude test #{Dir["origin-server/common/**/*.rb"].join(' ')}"
        run "yardoc --output-dir '#{repo_parent_dir}/origin-docs/build-tools' --main origin-dev-tools/README.md --private --protected --exclude test #{Dir["origin-dev-tools/build/*"].join(' ')}"
      end
    end

    desc "build_vm_image", "Build a VM disk image"
    method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"    
    method_option :terminate, :type => :boolean, :desc => "Terminate the instance when finished"    
    # Task to build an OpenShift Origin VM image
    #
    # @param options [Hash] Thor options hash
    #   - --verbose: Enable verbose logging
    def build_vm_image
      options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR
      def_constants(guess_os("fedora"))

      # Override the machine type to launch if necessary
      $amz_options[:instance_type] = options[:instance_type] if options[:instance_type]
      $amz_options[:block_device_mappings] = {"/dev/sdb" => "ephemeral0"}
  
      # Establish a new connection
      conn = connect(options.region)
  
      image = nil
      # Create a new builder instance
      if (options.region?nil)
        image = conn.images[AMI["us-east-1"]]
      elsif AMI[options.region].nil?
        puts "No AMI specified for region:" + options.region
        exit 1
      else
        image = conn.images[AMI[options.region]]
      end

      puts "Launching AMI: #{image.id} - #{image.name}"
      instance = launch_instance(image, "oso-image-builder", 1, SSH_USER)
      hostname = instance.dns_name
      puts "Done"
      puts "Hostname: #{hostname}"
      ssh(hostname, 'su - -c "setenforce 0"' , 60, false, 1, SSH_USER)
      ssh(hostname, 'su - -c "yum update -y"' , 300, false, 1, SSH_USER)
      ssh(hostname, 'su - -c "yum install -y appliance-tools qemu-img"' , 60, false, 1, SSH_USER)
      scp_to(hostname, File.expand_path("#{__FILE__ }/../templates/openshift-origin.ks"), '/home/ec2-user/openshift-origin.ks', 60, 5,SSH_USER)
      scp_to(hostname, File.expand_path("#{__FILE__ }/../templates/openshift-origin.vmx"), '/home/ec2-user/openshift-origin.vmx', 60, 5,SSH_USER)
      scp_to(hostname, File.expand_path("#{__FILE__ }/../templates/openshift-origin.vbox"), '/home/ec2-user/openshift-origin.vbox', 60, 5,SSH_USER)      
      ssh(hostname, 'su - -c "mv -f /home/ec2-user/openshift-origin.ks /mnt/"' , 60, false, 1, SSH_USER)
      ssh(hostname, 'su - -c "mkdir -p /mnt/tmp/build && mkdir -p /mnt/openshift-origin"', 60, false, 1,SSH_USER)
      ssh(hostname, 'su - -c "which VBoxManage 2>&1 > /dev/null || yum install -y http://download.virtualbox.org/virtualbox/4.2.8/VirtualBox-4.2-4.2.8_83876_fedora18-1.x86_64.rpm"', 60, false, 1, SSH_USER)
      ssh(hostname, 'su - -c "cd /mnt && appliance-creator -d -n openshift-origin -c openshift-origin.ks ' +
          '--format=vmdk --vmem=1024 --checksum --logfile=build.log --tmpdir=/mnt/tmp/build --cache /mnt/tmp/cache/"', 2400, false, 1, SSH_USER)
      ssh(hostname, 'su - -c "' + %{
        /bin/cp -f /mnt/openshift-origin.ks /mnt/openshift-origin/ &&
        /bin/mv -f /home/ec2-user/openshift-origin.v* /mnt/openshift-origin/ && 
        mkdir -p /root/.VirtualBox/ &&
        /bin/cp -f /mnt/openshift-origin/openshift-origin.vbox /root/.VirtualBox/openshift-origin.vbox &&
        ln -sf /mnt/openshift-origin/openshift-origin-sda.vmdk /root/.VirtualBox/openshift-origin-sda.vmdk &&
        pushd /root/.VirtualBox/ &&
        VBoxManage registervm openshift-origin.vbox &&
        VBoxManage  storageattach \\\"OpenShift Origin\\\" --storagectl SATA --type hdd --port 0 --medium openshift-origin-sda.vmdk &&
        /bin/cp -f /root/.VirtualBox/openshift-origin.vbox /mnt/openshift-origin/openshift-origin.vbox && 
        popd && 
        cd /mnt/openshift-origin && tar zcf openshift-origin.tgz * &&
        VBoxManage unregistervm \\\"OpenShift Origin\\\"
      } + '"' , 2400, false, 1, SSH_USER)
      FileUtils.mkdir_p "vm/"
      scp_from(hostname, "/mnt/openshift-origin/openshift-origin.tgz", "vm/", 1200, SSH_USER)
      begin
        terminate_instance(hostname) if options.terminate?
      rescue
        # suppress termination errors - they have been logged already
      end
    end

    no_tasks do
      alias_method :old_install_required_packages, :install_required_packages
    end

    def install_required_packages
      base_os = guess_os
      puts "Install packages required for build"
      
      if `rpm -q activemq`.match(/is not installed/)
        run "yum erase -y activemq"
        if base_os == "fedora"
          run "yum install -y https://mirror.openshift.com/pub/origin-server/fedora-18/x86_64/activemq-5.6.0-4.fc18.x86_64.rpm"
        elsif(base_os == "rhel" or base_os == "centos")
          run "yum install -y https://mirror.openshift.com/pub/origin-server/rhel-6/x86_64/activemq-5.6.0-1.el6_3.x86_64.rpm"
        end
      end
      
      if base_os == "fedora"
        run "yum -y update --enablerepo updates-testing ruby ruby-irb ruby-libs ruby-devel"
        run("gem install rspec -v '1.1.12'", options)
      end

      run "wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat/jenkins.repo"
      run "rpm --import http://pkg.jenkins-ci.org/redhat/jenkins-ci.org.key"      
      run "yum install -y tito make tig mlocate bash-completion activemq-client"

      old_install_required_packages
    end
    
    desc "local_build", "Builds and installs all packages locally"
    method_option :base_os, :default => nil, :desc => "Operating system for Origin (fedora or rhel)"
    method_option :verbose, :type => :boolean, :desc => "Enable verbose logging"
    method_option :clean_packages, :type => :boolean, :desc => "Erase existing packages before install?"
    method_option :update_packages, :type => :boolean, :desc => "Run yum update before install?"
    method_option :incremental, :type => :boolean, :desc => "Build only the changed packages"
    def local_build
      options.verbose? ? @@log.level = Logger::DEBUG : @@log.level = Logger::ERROR
      def_constants(guess_os(options.base_os))
      
      if options.incremental
        options.retry_failure_with_tag = false
        update
      else
        FileUtils.rm_f "/etc/yum.repos.d/local-openshift-origin.repo"
        FileUtils.rm_rf "/tmp/tito"
        
        packages = get_packages(false, true).values

        if options.clean_packages?
          run("yum clean all", options)
          package_names = "\"#{packages.join("\" \"")}\""
          puts "Removing stale packages..."
          run("yum erase -y #{package_names}", options)
        end
        
        if options.update_packages?
          puts "Updating all packages on the system..."
          run("yum update -y --exclude activemq", options)
          puts "Done"
        end

        find_and_build_specs

        FileUtils.rm_rf "/root/origin-rpms"
        FileUtils.rm_rf "/data/origin-srpms"
        FileUtils.mkdir_p "/root/origin-rpms"
        FileUtils.mkdir_p "/data/origin-srpms"        
        File.open("/etc/yum.repos.d/local-openshift-origin.repo", 'w') do |out|
          out << %{
[openshift-origin]
name    = openshift-origin
baseurl = file:///root/origin-rpms
gpgcheck= 0
enabled = 1
retries = 0
          }
        end
        run("cp /tmp/tito/x86_64/*.rpm /root/origin-rpms/; cp /tmp/tito/noarch/*.rpm /root/origin-rpms/; createrepo /root/origin-rpms/", options)
        run("cp /tmp/tito/*.src.rpm /data/origin-srpms/; chown -R #{SSH_USER}:#{SSH_USER} /data/origin-srpms", options)
        run("yum clean all")
        
        packages_to_install = packages.select{ |p| not IGNORE_PACKAGES.include?(p.name) }
        package_list = "\"#{packages_to_install.join("\" \"")}\""
        run("yum install -y #{package_list}", options)

        #mark all packages as sync'd
        get_sync_dirs
      end
    end


    no_tasks do
      def ssh_user
        return SSH_USER
      end

      def download_artifacts(hostname)
        puts "Downloading logs and screenshots..."
        `rm -rf rhc/log origin-rpms origin-srpms; mkdir -p rhc/log/; mkdir -p origin-rpms; mkdir -p origin-srpms; pushd rhc/log > /dev/null; mkdir -p broker mcollective system screenshots selenium jbossas broker-profiler coverage; popd > /dev/null`
        scp_from(hostname, "/tmp/rhc/*", "rhc/log", 60, ssh_user)
        scp_from(hostname, "/var/log/openshift/broker/*", "rhc/log/broker", 60, ssh_user)
        scp_from(hostname, "/var/log/openshift/user_action.log", "rhc/log/broker/user_action.log", 60, ssh_user)
        scp_from(hostname, "/var/log/mcollective.*", "rhc/log/mcollective", 60, ssh_user)
        scp_from(hostname, "/var/log/httpd/access_log", "rhc/log/system/access_log.log", 60, ssh_user)
        scp_from(hostname, "/var/log/httpd/error_log", "rhc/log/system/error_log.log", 60, ssh_user)
        scp_from(hostname, "/var/log/yum.log", "rhc/log/system/yum.log", 60, ssh_user)
        scp_from(hostname, "/var/log/messages", "rhc/log/system/messages.log", 60, ssh_user)
        scp_from(hostname, "/var/log/secure", "rhc/log/system/secure.log", 60, ssh_user)
        scp_from(hostname, "/var/log/audit/audit.log", "rhc/log/system/audit.log", 60, ssh_user)
        scp_from(hostname, "/tmp/rhc/*_coverage", "rhc/log/coverage", 60, ssh_user)

        ssh(hostname, "su - -c \"
          rm -rf /tmp/origin-rpms;
          mkdir -p /tmp/origin-rpms;
          cp -rf /root/origin-rpms/*.rpm /tmp/origin-rpms/;
          chown #{SSH_USER}:#{SSH_USER} -R /tmp/origin-rpms\"", 60, false, 2, ssh_user)
        scp_from(hostname, "/tmp/origin-rpms/*.rpm", "origin-rpms", 300, ssh_user)
        scp_from(hostname, "/data/origin-srpms/*.src.rpm", "origin-srpms", 300, ssh_user)
        puts "Done"
      end
      
      def validate_instance(hostname, num_tries=1)
      end
      
      def update_cucumber_tests(hostname, repo_parent_dir="/data", user="root")
        ssh(hostname, "
          rm -f #{repo_parent_dir}/openshift-test/tests; 
          ln -s #{repo_parent_dir}/openshift-test/controller/test/cucumber #{repo_parent_dir}/openshift-test/tests ;", 60, false, 2, user)
      end

      def setup_verifier(hostname, branch)
        update_remote_tests(hostname, branch, "/data", ssh_user)
      end

      def rpm_manifest(hostname, sshuser="root")
        print "Retrieving RPM manifest.."
        manifest, exit_code = ssh(hostname, 'rpm -qa | grep -E "(rhc|openshift)" | grep -v cartridge', 60, true, 1, sshuser)
        if exit_code != 0
          puts "Error retrieving manifest #{manifest}"
          exit 1
        end
        manifest = manifest.split("\n").sort.join(" / ")
        # Trim down the output to 255 characters
        manifest.gsub!(/rubygem-([a-z])/, '\1')
        manifest.gsub!('openshift-origin-', '')
        manifest.gsub!('mcollective-', 'mco-')
        manifest.gsub!('.fc16', '')
        manifest.gsub!('.noarch', '')
        manifest.gsub!(/\.git\.[a-z0-9\.]+/, '')
        manifest = manifest[0..254]
        puts "Done"
        return manifest
      end

      def wrap_test_command(command)
        if BASE_OS == "fedora"
          "su - -c \"#{command}\""
        elsif(BASE_OS == "rhel" or BASE_OS == "centos")
          "/usr/bin/scl enable ruby193 \"#{command}\""
        end
      end

      def test_impl(tag, hostname, instance, conn, options, image_id=nil)
        begin
          
          validate_instance(hostname, 4)
          mcollective_logs(hostname) if options.mcollective_logs?
          reset_test_dir(hostname, false, SSH_USER)
          test_queues = [[], [], [], []]

          ssh(hostname, wrap_test_command("echo 'export REGISTER_USER=1' > /etc/profile.d/testenv.sh") , 60, false, 2, SSH_USER)
          ssh(hostname, wrap_test_command("echo 'export RHC_DOMAIN=example.com' >> /etc/profile.d/testenv.sh"), 60, false, 2, SSH_USER)
          ssh(hostname, wrap_test_command("echo 'export RHC_SERVER=#{hostname}' >> /etc/profile.d/testenv.sh"), 60, false, 2, SSH_USER)
          ssh(hostname, "oo-register-user -ladmin -padmin --username user_with_multiple_gear_sizes@test.com --userpass test" , 60, false, 2, SSH_USER)
          ssh(hostname, "oo-register-user -ladmin -padmin --username user_with_extra_storage@test.com --userpass test" , 60, false, 2, SSH_USER)
            
          extended_tests = nil
          if options.include_extended
            extended_tests = []
            extended_tests = options.include_extended.split(",").map do |extended_test|
              extended_test.strip
            end
          end

          if options.include_extended
            extended_tests.each do |extended_test|
              case extended_test
              when 'broker'
                test_queues[0] << ["REST API Group 1", wrap_test_command("cucumber #{CUCUMBER_OPTIONS} -t @broker_api1 /data/openshift-test/tests"), {:retry_individually => true}]
                test_queues[1] << ["REST API Group 2", wrap_test_command("cucumber #{CUCUMBER_OPTIONS} -t @broker_api2 /data/openshift-test/tests"), {:retry_individually => true}]
                test_queues[2] << ["REST API Group 3", wrap_test_command("cucumber #{CUCUMBER_OPTIONS} -t @broker_api3 /data/openshift-test/tests"), {:retry_individually => true}]
                test_queues[3] << ["REST API Group 4", wrap_test_command("cucumber #{CUCUMBER_OPTIONS} -t @broker_api4 /data/openshift-test/tests"), {:retry_individually => true}]
                test_queues[2] << ["OpenShift Broker Functionals Ext", wrap_test_command("cd /data/openshift-test/broker; bundle exec rake test:functionals_ext"), {:retry_individually => true}]
              when 'runtime'
                test_queues[0] << ["Extended Runtime Group 1", wrap_test_command("cucumber #{CUCUMBER_OPTIONS} -t @runtime_extended1 /data/openshift-test/tests")]
                test_queues[1] << ["Extended Runtime Group 2", wrap_test_command("cucumber #{CUCUMBER_OPTIONS} -t @runtime_extended2 /data/openshift-test/tests")]
                test_queues[2] << ["Extended Runtime Group 3", wrap_test_command("cucumber #{CUCUMBER_OPTIONS} -t @runtime_extended3 /data/openshift-test/tests")]
              when 'rhc'
                test_queues[0] << ["RHC Extended", wrap_test_command("cucumber #{CUCUMBER_OPTIONS} -t @rhc_extended /data/openshift-test/tests"), {:retry_individually => true}]
                test_queues[1] << ["RHC Integration", wrap_test_command("cd /data/openshift-test/rhc && RHC_SERVER=#{hostname} QUIET=1 bundle exec \\\"cucumber #{CUCUMBER_OPTIONS} features\\\""), {:retry_individually => true}]
              else
                puts "No extended tests available for: #{extended_test}"
              end
            end
          elsif options.include_cucumber
            timeout = @@SSH_TIMEOUT
            timeout = @@SSH_TIMEOUT_OVERRIDES[options.include_cucumber] if not @@SSH_TIMEOUT_OVERRIDES[options.include_cucumber].nil?
            test_queues[0] << [options.include_cucumber, wrap_test_command("cucumber #{CUCUMBER_OPTIONS} -t @#{options.include_cucumber} /data/openshift-test/tests"), {:timeout => timeout}]
          elsif options.include_web?
            puts "No tests available for web"
          else
            unless options.exclude_broker?
              #test_queues[1] << ["OpenShift Broker Units", "cd /data/openshift-test/broker; rake test:units"]
              test_queues[0] << ["OpenShift Broker Integration", wrap_test_command("cd /data/openshift-test/broker; cp /var/www/openshift/broker/Gemfile.lock . ; bundle install --system ; bundle exec rake test:integration")]
              test_queues[2] << ["OpenShift Broker Functional", wrap_test_command("cd /data/openshift-test/broker; cp /var/www/openshift/broker/Gemfile.lock . ; bundle install --system ; bundle exec rake test:functionals")]
              test_queues[3] << ["Broker Cucumber", wrap_test_command("cucumber #{BROKER_CUCUMBER_OPTIONS} -t @broker /data/openshift-test/tests")]
            end

            unless options.exclude_runtime?
              #test_queues[0] << ["Runtime Unit", "cd /data/openshift-test/node; su - -c \"rake unit_test\""]
              (1..4).each do |i|
                test_queues[i-1] << ["Runtime Group #{i.to_s}", wrap_test_command("cucumber #{CUCUMBER_OPTIONS} -t @runtime#{i.to_s} /data/openshift-test/tests")]
              end
            end
  
            unless options.exclude_rhc?
              test_queues[0] << ["RHC Spec", "su - -c \"cd /data/openshift-test/rhc ; bundle install --path=/tmp/rhc_bundle && bundle exec rake spec\""]
            end
          end
  
          threads = []
          failures = []
  
          retry_threshold = 0
          test_queues.each do |test_queue|
            titles = []
            cmds = []
            retry_individually = []
            timeouts = []
            test_queue.each do |test|
              titles << test[0]
              cmds << test[1]
              opts = test[2] || {}
              retry_individually << opts[:retry_individually] ? true : false
              timeouts << opts[:timeout] ? opts[:timeout] : @@SSH_TIMEOUT
              retry_threshold += 8
            end
            add_ssh_cmd_to_threads(hostname, threads, failures, titles, cmds, retry_individually, timeouts, ssh_user)
          end
  
          threads.each do |t|
            t[0].join
          end
  
          failures.uniq!
  
          begin
            if failures.length > 0 && failures.length <= retry_threshold 
              #idle_all_gears(hostname)
              retry_test_failures(hostname, failures, 2, timeout=@@SSH_TIMEOUT, ssh_user)
            elsif failures.length > retry_threshold
              exit 1
            end
  
            # These are special tests that cannot be written to work concurrently
            if options.include_extended
              extended_tests.each do |extended_test|
                case extended_test
                when 'broker'
                when 'runtime'
                  singleton_queue = ['Singletons', wrap_test_command("cucumber #{CUCUMBER_OPTIONS} -t @singleton /data/openshift-test/tests")]
                  output, exit_code = run_ssh(hostname, singleton_queue[0], singleton_queue[1], timeout=@@SSH_TIMEOUT, ssh_user)
                  retry_test_failures(hostname, [singleton_queue], 2, timeout=@@SSH_TIMEOUT, ssh_user) if 0 != exit_code
                when 'site'
                when 'rhc'
                else
                  puts "Not supported for extended: #{extended_test}"
                  exit 1
                end
              end
            end
  
            validate_instance(hostname, 4)
          end
  
          if options.official?
            image_id = image_id ? image_id : instance.image_id
            # Mark the image as verified
            image = conn.images[image_id]
            verify_image(image)
  
            puts "Sending QE ready email..."
            begin
              send_verified_email(image_id, image.name)
            rescue Exception => e
              puts "Failed sending email with message: #{e.message}"
            end
          end
  
          puts "Done"
  
        ensure
          download_artifacts(hostname)
          
          begin
            terminate(tag) if options.terminate?
          rescue
            # suppress termination errors - they have been logged already
          end
        end
      end

      def sync_impl(name, options)
        # Get the hostname from a tag lookup or assume it's SSH accessible directly
        hostname = get_host_by_name_or_tag(name, options, ssh_user)

        clone_commands, working_dirs = sync_available_sibling_repos(hostname, "/data", ssh_user)
        update_remote_tests(hostname, nil, "/data", ssh_user)
        
        ret = 0
        if !options.skip_build?
          puts "Performing remote install..."

          out, ret = ssh(hostname, "cd /data/ ; rm -rf #{working_dirs}; #{clone_commands}", 60 * 5, true, 1, ssh_user)
          print_and_exit(ret, out) if ret != 0

          out, ret = ssh(hostname, "su - -c \"yum clean metadata\"", 60 * 2, true, 2, ssh_user) if options.clean_metadata?
          print_and_exit(ret, out) if ret != 0

          cmd = "build/devenv update"
          cmd += " --verbose" if options.verbose
          cmd += " --include_stale" if options.clean_metadata

          if(BASE_OS == "rhel" or BASE_OS == "centos")
            cmd = "scl enable ruby193 \\\"#{cmd}\\\""
          end
          out, ret = ssh(hostname, "su - -c \"cd /data/origin-dev-tools; #{cmd}  2>&1 \"", 60 * 15, true, 1, ssh_user) if ret == 0
          print_and_exit(ret, out) if ret != 0

          out, ret = ssh(hostname, "su - -c \"#{options.clean_metadata? ? "yum update -y rhc *openshift*" : ''}\"", 60 * 15, true, 1, ssh_user) if options.clean_metadata?
          print_and_exit(ret, out) if ret != 0
          
          post_launch_setup(hostname)
        end

        puts "Done"
      end
  
      def build_impl(name, build_num, image, conn, options)
        $amz_options[:block_device_mappings] = {"/dev/sdb" => "ephemeral0"}

        puts "Launching AMI: #{image.id} - #{image.name}"
        instance = launch_instance(image, name + "_" + build_num, 1, ssh_user)

        hostname = instance.dns_name
        puts "Done"
        puts "Hostname: #{hostname}"
        
        ret, out = 0, nil
        begin
          if options.install_required_packages?
            puts "Starting yum update..."
            out, ret = ssh(hostname, "su - -c \"yum -y update\"", 60 * 20, true, 1, ssh_user)
            print_and_exit(ret, out) if ret != 0
            print_highlighted_output("Update Output", out)
            out, ret = ssh(hostname, "su - -c \"yum install -y ruby ruby-irb ruby-libs ruby-devel rubygem-thor\"", 60 * 20, true, 1, ssh_user)
            print_and_exit(ret, out) if ret != 0
            print_highlighted_output("Update Output", out)
            out, ret = ssh(hostname, "su - -c \"yum erase -y epel-release\"", 60 * 20, true, 1, ssh_user)
            print_and_exit(ret, out) if ret != 0
            print_highlighted_output("Update Output", out)
            if(BASE_OS == "rhel" or BASE_OS == "centos")
              out, ret = ssh(hostname, "su - -c \"yum -y install http://dl.fedoraproject.org/pub/epel/6/i386/epel-release-6-8.noarch.rpm\"", 60 * 20, true, 1, ssh_user)
              print_and_exit(ret, out) if ret != 0
              print_highlighted_output("Update Output", out)
            end
            
            out, ret = ssh(hostname, "su - -c \"yum install -y git rubygem-thor rubygem-cucumber\"", 60 * 10, true, 1, ssh_user)
            print_and_exit(ret, out) if ret != 0
            print_highlighted_output("Install Output", out)
          end

          puts "Creating mount..."
          if options.install_from_source? || options.install_from_local_source?
            out, ret = ssh(hostname, "su - -c \"rm -rf /data\"", 60 * 10, true, 1, ssh_user)
            print_and_exit(ret, out) if ret != 0
          end
          #out, ret = ssh(hostname, "su - -c \"umount -l /data ; if [ ! -b /dev/xvdb ]; then /sbin/mke2fs /dev/xvdb; fi; mkdir -p /data && mount /dev/xvdb /data && chown -R #{SSH_USER}:#{SSH_USER} /data/\"", 60 * 10, true, 1, ssh_user)
          out, ret = ssh(hostname, "su - -c \"mkdir -p /data && chown -R #{SSH_USER}:#{SSH_USER} /data/\"", 60 * 10, true, 1, ssh_user)
          print_and_exit(ret, out) if ret != 0

          init_repos(hostname, true, nil, "/data", ssh_user)
          clone_commands, working_dirs = '', ''

          if options.install_from_local_source?
            puts "Performing clean install from local source..."
            clone_commands, working_dirs = sync_available_sibling_repos(hostname, "/data", ssh_user)
          else
            SIBLING_REPOS.each do |repo_name, repo_dirs|
              working_dirs += "#{repo_name} "
              clone_commands += "git clone #{repo_name}-bare #{repo_name}; "
              clone_commands += "pushd #{repo_name}; git checkout #{options.branch}; popd; "
            end
          end
          out, ret = ssh(hostname, "cd /data; rm -rf #{working_dirs}; #{clone_commands}", 60 * 5, true, 2, ssh_user)
          print_and_exit(ret, out) if ret != 0
          puts "Done"

          if options[:extra_rpm_dir]
            if File.exist? options[:extra_rpm_dir]
              out, ret = ssh(hostname, "mkdir -p /data/origin-server/build/extras", 60, true, 1, ssh_user)
              files = Dir.glob("#{options[:extra_rpm_dir]}/*.rpm")
              files.each do |file|
                scp_to(hostname, file, "/data/origin-server/build/extras/", 60*10, 5, ssh_user)
              end

              out, ret = ssh(hostname, "su - -c \"cd /data/origin-server/build/extras && yum install -y *.rpm\"", 60 * 20, true, 1, ssh_user)
            else
              puts "!!!Warning!!!"
              puts "Directory containing extra rpms not found. Skipping..."
              puts "!!!Warning!!!"
            end
          end
          
          if(BASE_OS == "rhel" or BASE_OS == "centos")
            puts "Install build script dependencies"
            out, ret = ssh(hostname, "su - -c \"cd /data/origin-dev-tools; build/devenv 2>&1 \"", 60 * 15, true, 1, ssh_user) if ret == 0
            print_highlighted_output("Build script dependencies", out)
          end
        
          puts "Installing pre-requisite packages"
          cmd = "build/devenv install_required_packages"
          if(BASE_OS == "rhel" or BASE_OS == "centos")
            cmd = "scl enable ruby193 \\\"#{cmd}\\\""
          end
          out, ret = ssh(hostname, "su - -c \"cd /data/origin-dev-tools; #{cmd} 2>&1 \"", 60 * 15, true, 1, ssh_user) if ret == 0
          print_and_exit(ret, out) if ret != 0
          
          print_highlighted_output("Install Output", out)

          # Add the paths to the users .bashrc file
          #out, ret = ssh(hostname, "echo \"export PATH=/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:$PATH\" >> ~/.bashrc", 60, true, 1, ssh_user)
          selinux_level="enforcing"
          selinux_level="permissive" if options.disable_selinux?

          out, ret = ssh(hostname, %{
cat<<EOF > /tmp/selinux_config
This file controls the state of SELinux on the system.
# SELINUX= can take one of these three values:
# enforcing - SELinux security policy is enforced.
# permissive - SELinux prints warnings instead of enforcing.
# disabled - No SELinux policy is loaded.
SELINUX=#{selinux_level}
# SELINUXTYPE= can take one of these two values:
# targeted - Only targeted network daemons are protected.
# strict - Full SELinux protection.
SELINUXTYPE=targeted
EOF
          }, 60 * 2, true, 1, ssh_user)
          print_and_exit(ret, out) if ret != 0
          out, ret = ssh(hostname, "su - -c \"cp /tmp/selinux_config /etc/selinux/config\"", 60 * 15, true, 1, ssh_user) if ret == 0
          print_and_exit(ret, out) if ret != 0
          if options.disable_selinux?
            out, ret = ssh(hostname, "su - -c \"/usr/sbin/setenforce 0\"", 60 * 15, true, 1, ssh_user) if ret == 0
            print_and_exit(ret, out) if ret != 0
          end
          base_os = guess_os(options.base_os)

          if options.install_required_packages?
            puts "Setting up puppet modules..."

            #puppet version 2.7
            out, ret = ssh(hostname, %{su - -c \"
              rm -rf /etc/puppet/modules &&
              mkdir -p /etc/puppet/modules &&
              puppet module install puppetlabs/stdlib &&
              puppet module install puppetlabs/ntp &&
              ln -sf /data/puppet-openshift_origin /etc/puppet/modules/openshift_origin
              \"}, 60 * 20, true, 1, ssh_user)
            print_and_exit(ret, out) if ret != 0
                        
            puts "Setting machine hostname"
            out, ret = ssh(hostname, %{
cat<<EOF > ~#{SSH_USER}/configure_hostname.pp
file { "update network settings - hostname": 
  path    => "/etc/sysconfig/network",
  content => "NETWORKING=yes\nNETWORKING_IPV6=no\nHOSTNAME=\\\${ec2_public_hostname}\n"
}
exec { "set hostname":
  command => "/bin/hostname \\\${ec2_public_hostname}"
}
EOF
            }, 60 * 2, true, 1, ssh_user)
            print_and_exit(ret, out) if ret != 0

            out, ret = ssh(hostname, %{
cat<<EOF > ~#{SSH_USER}/configure_origin.pp
\\\$keyfile="/var/named/Kexample.com.*.key"
\\\$key=inline_template("<%=File.read(Dir.glob(keyfile)[0]).strip.split(\' \')[7]%>")
class { "openshift_origin" :
  node_fqdn           => \\\$ec2_public_hostname,
  cloud_domain        => "example.com",
  named_tsig_priv_key => \\\$key,
  dns_servers         => ["172.16.0.23"],
  os_unmanaged_users  => ["#{SSH_USER}"],
  install_repo        => "file:///root/origin-rpms",
  development_mode    => true,
  configure_cgroups   => #{base_os=='fedora'? 'false':'true'},
}
EOF
            }, 60 * 2, true, 1, ssh_user)
            print_and_exit(ret, out) if ret != 0
          else
            if options.install_from_source? || options.install_from_local_source?
              puts "Installing Origin packages..."
              cmd = "build/devenv local_build --clean-packages"
              if(BASE_OS == "rhel" or BASE_OS == "centos")
                cmd = "scl enable ruby193 \\\"#{cmd}\\\""
              end
              out, ret = ssh(hostname, "su - -c \"cd /data/origin-dev-tools; #{cmd}  2>&1 \"", 60 * 15, true, 1, ssh_user) if ret == 0
              print_and_exit(ret, out) if ret != 0
            
              out = ssh(hostname, "su - -c \"rpm -qa | grep openshift\"", 60, false, 1, ssh_user)
              print_highlighted_output("Installed Origin Packages", out)
            
              puts "Running broker setup..."
              out, ret = ssh(hostname, 'su - -c "rm -rf /var/named/Kexample.com*"', 60 * 20, true, 1, ssh_user)
              print_and_exit(ret, out) if ret != 0
              out, ret = ssh(hostname, 'su - -c "yum install -y bind"', 60 * 20, true, 1, ssh_user)
              print_and_exit(ret, out) if ret != 0
              out, ret = ssh(hostname, 'su - -c "/usr/sbin/dnssec-keygen -a HMAC-MD5 -b 512 -n USER -r /dev/urandom -K /var/named example.com"', 60 * 20, true, 1, ssh_user)
              print_and_exit(ret, out) if ret != 0
              out, ret = ssh(hostname, 'TSIG_KEY=`su - -c "cat /var/named/Kexample.com.*.key") | awk "{ print $8 }"` ; echo $TSIG_KEY', 60 * 20, true, 1, ssh_user)
              print_and_exit(ret, out) if ret != 0
              
              post_launch_setup(hostname)
            end
          end
          puts "Done"          

          image_id = nil
          if options[:register]
            # reset the eth0 network config to remove the HWADDR
            puts "Removing HWADDR and DNS entries from eth0 network config..."
            reset_eth0_dns_config(hostname)
            
            manifest = rpm_manifest(hostname, ssh_user)              
            registered_ami = register_image(conn, instance, name + '_' + build_num, manifest)
            image_id = registered_ami.id
          end

          # Register broker dns and restart the network
          unless options.install_required_packages?  
            post_launch_setup(hostname)
          end

          unless options.skip_verify? || options.install_required_packages?
            update_remote_tests(hostname, options.branch, "/data", ssh_user)
            test_impl(name + '_' + build_num, hostname, instance, conn, options, image_id)
          end
          puts "Done."
        ensure
          begin
            terminate(name + '_' + build_num) if options.terminate?
          rescue
            # suppress termination errors - they have been logged already
          end
        end
      end

      def reset_eth0_dns_config(hostname)
cmd = %{
su - -c \"echo \\\"DEVICE=eth0
BOOTPROTO=dhcp
ONBOOT=yes
\\\" > /etc/sysconfig/network-scripts/ifcfg-eth0\"

su - -c \"/etc/init.d/network restart\"
su - -c \"service named restart\"
}
        out, ret = ssh(hostname, cmd, 60 * 5, true, 1, ssh_user)
        print_and_exit(ret, out) if ret != 0
      end
  
      def sanity_check_impl(tag, hostname, instance, conn, options, image_id=nil)
        threads = []
        failures = []
        titles = ["OpenShift Origin Broker Sanity",
                  "OpenShift Origin Node Unit"]
    
        cmds = ["su - -c \"cd /var/www/openshift/broker; bundle exec rake test:sanity\"",
                "cd /data/openshift-test/node; su - -c \"rake unit_test\""]
        add_ssh_cmd_to_threads(hostname, threads, failures, titles, cmds, false, @@SSH_TIMEOUT, ssh_user)
        add_ssh_cmd_to_threads(hostname, threads, failures, "Cucumber Sanity", "cucumber #{CUCUMBER_OPTIONS} -t @sanity /data/openshift-test/tests/", false, @@SSH_TIMEOUT, ssh_user)
    
        threads.each do |t|
          t[0].join
        end
    
        unless failures.empty?
          failures.uniq!
          retry_test_failures(hostname, failures, 1, @@SSH_TIMEOUT, ssh_user)
        end
      end
      
      def update_facts_impl(hostname)
      end
      
      def post_launch_setup(hostname)
        # reset the eth0 network config to add the dns entries
        out, ret = ssh(hostname, "su - -c \"puppet apply --verbose ~#{SSH_USER}/configure_hostname.pp\"", 60 * 20, true, 1, ssh_user)
        print_and_exit(ret, out) if ret != 0
        
        out, ret = ssh(hostname, "su - -c \"puppet apply --verbose ~#{SSH_USER}/configure_origin.pp\"", 60 * 20, true, 1, ssh_user)
        print_and_exit(ret, out) if ret != 0
        print_highlighted_output( "Origin setup", out)
        restart_services_remote(hostname)
      end

      def restart_services
        cmd = %{
        su - -c \"service mongod restart\"
        su - -c \"service activemq restart; \"
        su - -c \"service cgconfig restart; service cgred restart ; service openshift-cgroups restart\"
        su - -c \"service httpd restart; service openshift-broker restart\"
        su - -c \"service openshift-console restart; service openshift-node-web-proxy stop\"
        su - -c \"service named restart; service network restart\"
        su - -c \"service mcollective restart;\"
        su - -c \"service start\"
        }
        run(cmd)
      end

      def restart_services_remote(hostname)
        puts "Restarting services..."

        cmd = %{
su - -c \"service mongod restart\"
su - -c \"service activemq restart\"
su - -c \"service httpd restart; service openshift-broker restart\"
su - -c \"service openshift-console restart; service openshift-node-web-proxy stop\"
su - -c \"service named restart; service network restart\"
su - -c \"service cgconfig restart; service cgred restart ; service openshift-cgroups restart\"
su - -c \"service mcollective restart;\"
su - -c \"service openshift-node-web-proxy start\"
}
        out, ret = ssh(hostname, cmd, 60 * 5, true, 1, ssh_user)
        print_and_exit(ret, out) if ret != 0
        puts "Done"
      end
    end # no_tasks end
  end # class end
end # module end
Origin::BuilderPlugin.start
